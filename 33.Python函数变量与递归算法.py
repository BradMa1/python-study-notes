# 一、引用变量与可变、非可变类型

# 1.引用变量
"""
在大多数编程语言中，值得传递通常可分为两种形式 “值传递与引用传递”，但在Python中，变量的传递只有引用传递，没有值传递。
"""

# 验证Python中变量的引用关系
'可以使用内置函数id()来查看变量的信息(内存地址)=>> id(变量名称)'
a = 10
print(id (a))

# 把一个变量赋予给另外一个变量的影响
a = 10
b = a
print(id (a))
print(id (b))

'说明：由以上运行结果可知，当把一个变量赋予给另一个变量时，其两者指向的内存地址相同。说明a和b指向的是同一个内存地址，即a和b是引用关系。'

"""总结：不可变数据类型（数值）在赋值以后，其中一个之的改变不影响另外一个变量，因为两者指向的空间地址不同"""


# 2.Python中可变与非可变数据类型
""""在Python中，数据类型分为两大类：可变类型 + 不可变类型"""

"""
非可变类型：数值（int整型、float浮点型）、bool类型（True和False）、字符串类型（str）、元组（tuple 1,2,3）
可变类型：列表（list[1,2,3]）、字典（dict{key:value}）、集合（set{1,2,3}）
"""

# 如何判断一个数据类型是可变类型还是非可变类型
"""在Python中，可变类型与非可变类型主要是通过这个数据类型在内存中的表现形式来进行定义的"""

"""
可变类型：在内存中其地址可以不变，但是其内部数据可以改变的一种数据结构。
"""
a = [1,2,3]
print(id(a))

# 向内存中追加新数据（对数据进行改变只能通过数据类型.方法()实现）
a.append(4)
print(id(a))

"""
非可变类型：在内存中内存地址一旦固定，其值就无法发生任何改变。
"""
a = 10
print(id(a))

a = 'hello'
print(id(a))

# 3.可变类型与非可变类型在函数中的应用

# 可变类型：
# 定义一个函数
def func(names):
    # 在函数内部更改可变变量names
    names.append('赵六')
    print(names)
    
# 定义一个全局变量
list1 = ['张三','李四','王五']
# 调用函数
func(list1)
"""综上所述：可变类型在函数中，如果在全局或局部中对可变类型进行增删改操作，其外部和内部都会收到影响"""

# 不可变类型：
# 定义一个
def func(num):
    num += 1
    print(num)
    
# 定义一个全局变量
a = 10
# 调用函数
func(a)
# 在全局作用域中打印a
print(a)




# 二、函数递归（重难点）

# 1.递推算法：
""""递推算法是一种简单的算法去，即通过已知条件，利用特定条件得出中间推论，直至得到结果的算法。递推又分为正推和逆推"""

"""
顺推：通过最简单的条件，然后逐步推演结果
逆推：通过结果找到规律，然后推导已知条件
"""

# 1.1递推算法案例：斐波那契数列
"""
1 1 2 3 5 8 13 21 ...
第1位位1，第2位为1，从第3位开始，每一位的值等于前两位之和

斐波那契数列的递推公式为：f(n) = f(n-1) + f(n-2)

"""

# 问题：求斐波那契数列第15位的值
"""
分析：f(15) = f(14) + f(13)
      f(14) = f(13) + f(12)
      f(13) = f(12) + f(11)
      
      ... 
      
      f(4) = f(3) + f(2)
      f(3) = f(2) + f(1)
      f(2) = 1
      f(1) = 1

递推算法：使用while或for循环实现
     
"""
def recusive(n):
    """返回斐波那契数列某一位(n>=1)的结果"""
    if n == 1 or n == 2:
        return 1
    # 开始递推f(3) = 2, f(4) = f(3) + f(2)...f(15) = f(14) + f(13)
    dict1 = {1:1, 2:1}
    for i in range(3,n+1):
        dict1[i] = dict1[i-1] + dict1[i-2]
    return dict1,dict1[n]

# 函数调用
print(recusive(15))


# 2.递归算法
"""
程序调用自身的编程技巧称为递归(recursion)。递归策略只需少量的程序就可描述出解题过程所需的多次重复计算，可以很大的减少程序的代码量
简化问题：找到最优子问题（不能再小）
函数自己调用自己
"""
def func():    
    # 自己调用自己
    func()

# 2.1 递归两种重要的元素
"""
1.递归点：找到解决当前问题的等价函数（先解决规模比当前问题小一些的函数，一次类推，最终实现对问题的解决）=>有递有归
2.递归出口：当问题解决的时候，已经达到（必须存在）最优问题，不能再次调用函数了
注：如果一个递归函数没有递归出口就变成了死循环
"""

# 2.2 编写递归的步骤
"""
1.明确函数编写的目的（函数的作用）
    如：求斐波那契数列
2.寻找递归结束条件
    如：在什么时候结束递归，返回结果（递归出口）
3.找i出函数的等价关系式
    如：斐波那契数列，第n位f(n) = f(n-1) + f(n-2)
"""

# 案例1：使用递归求斐波那契数列
# 斐波那契数列：1 1 2 3 5 8 13 21 ...

# 第一步：确函数编写的目的（函数的作用）先定义出来，明确调用方式
def f(n):
    # 第二步：寻找递归结束条件
    # 编写递归代码求第n位的结果
    if n == 1 or n == 2:
        return 1
    # 找出斐波那契数列等价的关系式
    # f(3) = f(2) + f(1)
    # f(4) = f(3) + f(2)
    # f(5) = f(4) + f(3)
    # ...
    # f(15) = f(14) + f(13)
    return f(n-1) + f(n-2)

# 调用函数
print(f(15))    # 610



# 案例2：使用递归求n的阶乘(如：n = 10)
"""阶乘：n! = n * (n-1) * (n-2) * ... * 1"""
'''
1! = 1
2! = 2 * 1
3! = 3 * 2 * 1
...
n! = f(n-1) * n
'''
# 第一步：明确这个函数要做什么，定义函数以及调用方式



def f(n):
    # 第二步：寻找递归的结束条件（编写递归结束条件）
    if n <= 2:  #  if n == 1 or n == 2:
        return n
    # 递归等价公式

print(f(100))

# 第三步：编写递归等价公布式（找规律）
def f(n):
    # 编写递归结束条件
    if n <= 2:  #  if n == 1 or n == 2:
        return n
    # 递归等价公式
    return f(n-1) * n

print(f(100))   # 3628800






# 案例3：猴子吃桃问题
"""
猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。
第二天早上又将剩下的桃子吃掉一半，又多吃了一个。
以后每天早上都吃了前一天剩下的一半零一个。
到第10天早上想再吃时，见只剩下一个桃子了。
求第一天共摘了多少个桃子。
"""
# 第一步：确定函数主要完成什么功能
def f(n):
    # 第二步：编写递归结束条件（出口）
    if n == 10:
        return 1
    # 第三步：编写递归等价公式
    '''
    假设有10个桃子
    第一天：10个桃子吃一半，10/2 = 5 + 1 = 6
    第二天：4个桃子吃了一半，4 / 2 + 1 = 3
    第三天：再想吃剩1个 
    第n天：总剩余桃子的数量=（第（n+1）天剩余桃子的数量 + 1）*2
    '''
    return (f(n+1) + 1) * 2


# 调用f函数
print(f(1))
