# 一、引用变量与可变、非可变类型

# 1.引用变量
"""
在大多数编程语言中，值得传递通常可分为两种形式 “值传递与引用传递”，但在Python中，变量的传递只有引用传递，没有值传递。
"""

# 验证Python中变量的引用关系
'可以使用内置函数id()来查看变量的信息(内存地址)=>> id(变量名称)'
a = 10
print(id (a))

# 把一个变量赋予给另外一个变量的影响
a = 10
b = a
print(id (a))
print(id (b))

'说明：由以上运行结果可知，当把一个变量赋予给另一个变量时，其两者指向的内存地址相同。说明a和b指向的是同一个内存地址，即a和b是引用关系。'

"""总结：不可变数据类型（数值）在赋值以后，其中一个之的改变不影响另外一个变量，因为两者指向的空间地址不同"""


# 2.Python中可变与非可变数据类型
""""在Python中，数据类型分为两大类：可变类型 + 不可变类型"""

"""
非可变类型：数值（int整型、float浮点型）、bool类型（True和False）、字符串类型（str）、元组（tuple 1,2,3）
可变类型：列表（list[1,2,3]）、字典（dict{key:value}）、集合（set{1,2,3}）
"""

# 如何判断一个数据类型是可变类型还是非可变类型
"""在Python中，可变类型与非可变类型主要是通过这个数据类型在内存中的表现形式来进行定义的"""

"""
可变类型：在内存中其地址可以不变，但是其内部数据可以改变的一种数据结构。
"""
a = [1,2,3]
print(id(a))

# 向内存中追加新数据（对数据进行改变只能通过数据类型.方法()实现）
a.append(4)
print(id(a))

"""
非可变类型：在内存中内存地址一旦固定，其值就无法发生任何改变。
"""
a = 10
print(id(a))

a = 'hello'
print(id(a))

# 3.可变类型与非可变类型在函数中的应用

# 可变类型：
# 定义一个函数
def func(names):
    # 在函数内部更改可变变量names
    names.append('赵六')
    print(names)
    
# 定义一个全局变量
list1 = ['张三','李四','王五']
# 调用函数
func(list1)
"""综上所述：可变类型在函数中，如果在全局或局部中对可变类型进行增删改操作，其外部和内部都会收到影响"""

# 不可变类型：
# 定义一个
def func(num):
    num += 1
    print(num)
    
# 定义一个全局变量
a = 10
# 调用函数
func(a)
# 在全局作用域中打印a
print(a)



# 二、函数递归（重难点）

# 1.递推算法：
""""递推算法是一种简单的算法去，即通过已知条件，利用特定条件得出中间推论，直至得到结果的算法。递推又分为正推和逆推"""

"""
顺推：通过最简单的条件，然后逐步推演结果
逆推：通过结果找到规律，然后推导已知条件
"""

# 递推算法案例：斐波那契数列
"""
1 1 2 3 5 8 13 21 ...
第1位位1，第2位为1，从第3位开始，每一位的值等于前两位之和

斐波那契数列的递推公式为：f(n) = f(n-1) + f(n-2)

"""

# 问题：求斐波那契数列第15位的值
"""
分析：f(15) = f(14) + f(13)
      f(14) = f(13) + f(12)
      f(13) = f(12) + f(11)
      
      ... 
      
      f(4) = f(3) + f(2)
      f(3) = f(2) + f(1)
      f(2) = f(1) + f(0)
      f(1) = 1
      f(0) = 1

递推算法：使用while或for循环实现
     
"""

def recusive(n):
    """返回斐波那契数列某一位(n>=1)的结果"""
    if n == 1:
        return 1

# 函数调用
recusive(1)


 